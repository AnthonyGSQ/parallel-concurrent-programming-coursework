= Paralela Anthony Sanchez Quiros

== Pthreads

[%autowidth]
|===
|# |Id |Type |Description
|1 |link:pthreads/commented_examples[commented_examples] |Homework | Basic
example of pthread_create.
|2 |link:pthreads/recursive_hello[recursive_hello] |Homework | Recursive
creating of threads.
|3 |link:pthreads/invert[invert] |Class_example |Serial program that invert
integer numbers gived in the standar entrance
|4 |link:pthreads/recursive_hello/trace[recursive_hello_trace] |Homework |
Memory trace of recursive_hello
|5 |link:pthreads/hello_w[hello_w] |Homework | Creating and joining threads
with cycle for
|6 |link:pthreads/grandma_lottery[grandma_lottery] |Class_example |Serial
program that invert integer numbers gived in the standar entrance
|7 |link:pthreads/hello_iwi_pri[hello_iwi_pri] |Homework | Basic example of
thread private data
|8 |link:pthreads/hello_iwi_shr[hello_iwi_shr] |Homework | Basic example of
thread public data
|9 |link:pthreads/hello_order_busywait[hello_order_busywait] |Homework | Basic
example of thread busy waiting
|10 |link:pthreads/team_shot_put[team_shot_put] |Homework | The program takes as
input n teams, each consisting of m athletes. Each athlete performs multiple
throws, and their best attempt is recorded. The program uses threads to handle
the execution efficiently. After all throws are processed, the team with the
highest combined best throws is declared the winner.
|11 |link:pthreads/create_thread_team[create_thread_team] |Class_example |
Exercise to solve team_shot_put using pthreads teams instead of normal pthreads
|12 |link:pthreads/race_position[race_position] |Homework | This program
simulates a race condition among threads, where only one thread can reach
position x, but the outcome is non-deterministic.
|13 |link:pthreads/hello_order_semaphor[hello_order_semaphor] |Homework | 
This program allow only one thread to print a greeting at the same time using
a semaphore for the threads
|14 |link:pthreads/birthday_pinata[birthday_pinata] |Class_example | This
program simulates a birthday party scenario where all threads must hit the
pinata until it breaks. The thread that breaks the pi√±ata must announce it.
|15 |link:pthreads/hello_order_cond_safe[hello_order_cond_safe] |Homework |
A program that allows threads to print in order using conditional safe to avoid
busy-waiting
|16 |link:pthreads/building_tasks[building_tasks] |Class_Example | This exercise
involves fixing a concurrent program that simulates task execution based on a
dependency graph, ensuring that no worker thread starts before all its
prerequisite tasks are completed.
|17 |link:pthreads/prod_cons_bound[prod_cons_bound] | Homework |This exercise
focuses on the bounded buffer problem, where a fixed-size buffer is shared
between producer and consumer threads that must be synchronized to avoid
overflows and underflows.
|17 |link:pthreads/prod_cons_bound_mod[prod_cons_bound_mod] | Homework | This
exercise addresses the unbounded buffer problem, where producer and consumer
threads interact with a buffer that can grow dynamically, requiring
synchronization but without the constraint of a fixed size.
|18 |link:pthreads/prod_cons_unbound_cpp[prod_cons_unbound] | Homework | Producer-consumer problem with an unbounded buffer implemented in C++.
|19 |link:taskc/network_simul_packet_loss[network_simul_packet_loss] | Class Example | Simulates network packet loss in a concurrent environment.
|20 |link:taskc/network_simul_packet_loss2[network_simul_packet_loss2] | Class Example | Variation of the network packet loss simulation.
|21 |link:taskc/network_simul_producers[network_simul_producers] | Class example | Simulates multiple producers in a network environment.
|22 |link:taskc/network_simul_bounded[network_simul_bounded] | Class example | Simulates a bounded network buffer with concurrent producers and consumers.
|23 |link:datap/amdahl_compare_ab[amdahl_compare_ab] | Homework | Compares speedup using Amdahl's Law.
|24 |link:taskc/taskc_patterns[taskc_patterns] | Class Example | Examples of common concurrency patterns.
|25 |link:openmp/omp_team[omp_team] | Class example | Example of team parallelism using OpenMP.
|26 |link:openmp/omp_for[omp_for] | Class example | Example of parallel for loops using OpenMP.
|26 |link:openmp/omp_several_for_stages[omp_several_for_stages] | Class example | Example of multiple parallel for stages with OpenMP.
|27 |link:openmp/omp_mergesort[omp_mergesort] | Class example | Parallel mergesort implementation using OpenMP.
|28 |link:openmp/omp_stats[omp_stats] | Class example | Statistical computations using OpenMP parallelism.
|29 |link:mpi/mpi_hello[mpi_hello] | Class example | Basic MPI hello world example.
|30 |link:mpi/wrapper[mpi_wrapper] | Class example | C++ wrapper class for MPI initialization and management.
|===

== Tasks

[#autowidth]
|===
|# |Id |Type |Description
|1 |link:homeworks/serial[serial] | Tarea01 | Program that stabilizes the temperatures of an n x m sheet, processing one cell of the sheet at a time
|2 |link:homeworks/pthread[pthread] | Tarea02 | Program that stabilizes the temperatures of an n x m sheet, processing multiple cells of the sheet at the same time.
|3 |link:homeworks/optimized[optimided] | Tarea03 | Program that stabilizes the temperatures of an n x m sheet, processing multiple cells of the sheet at the same time, but with a more efficient algorithm than pthread homework version.
|===

== Glosary

=== Programacion serial

Es un paradigma de programacion donde la realizacion de tareas es serial, es decir, se realiza primeramente tarea1 y hasta que no sea
finalizada, no se prosigue con tarea2


=== Programacion Concurrente

Es un paradigma de programacion que puede basarse en la programacion iperativa o funcional. A diferencia de la programacion serial, la concurrente puede realizar varias tareas a la vez. Un ejemplo seria, mientras tarea01 termina, ir realizando tarea2


=== Programacion paralela

Se refiere a la programacion que es capaz de realizar varias tareas al mismo tiempo. Es decir, realizar tarea1 y tarea2 a la vez, en el mismo instante


=== Concurrencia de tareas

Se refiere a cuando varios hilos acceden a los mismos datos, esto puede generar problemas de condiciones de carreras.


=== Paralelismo de datos

Se refiere a cuando un conjunto de datos es trabajado es dividido en fragmentos y cada fragmento es procesado en paralelo en distintas unidades de procesamiento


=== Hilo de ejecucion

Un hilo de ejecucion se refiere a un ejecutante capaz de realizar tareas de forma paralela con otros ejecutantes (hilos).
=== Indeterminismo

El indeterminismo es cuando no se sabe que hilo terminara su trabajo primero, poniendo un ejemplo seria enviar 2 hilos a realizar exactamente la misma tarea. A veces el hilo 1 terminara primero, a veces sera el segundo.


=== Memoria privada y compartida

La memoria privada se refiere a las variables, datos, structs que solamente un hilo tiene acceso a ellos. Por otra parte la memoria compartida es aquella a la cual varios hilos tienen acceso.

=== Espera activa

Se refiere a cuando los hilos estan esperando a que se cumpla x condicion para poder realizar la tarea que se les ha asignado, sin embargo mientras esperan consumen recursos de la CPU, ralentizandola gravemente, es la peor practica de programacion que se puede realizar.

=== Condicion de carrera

La condicion de carrera es cuando n hilos realizan x procedimientos a partir de datos que estan siendo leidos y editados de manera concurrente, generando un indeterminismo de resultados no deseados.

=== Control de concurrencia

Es un metodo que evita la espera activa de hilos, haciendo que estos en lugar de esperar consumiendo recursos, esperen sin dicho consumo, se podria decir que los hilos se "duermen".

=== Seguridad condicional

Es un metodo de control de concurrencia que hace "esperar" a n hilos hasta que se cumpla una determinada condicion.

=== Exclusion mutua

Herramienta de control de concurrencia que evita que mas de un hilo acceda a x dato, evitando posibles condiciones de carrera.

=== Semaforo

Herramienta de control de concurrencia que le permite a n hilos poder realizar x actividad a la vez, enviando un signal cada que el semaforo vacia uno de los espacios que tiene disponibles, permmitiendole a otros hilos acceder a x actividad.

=== Barrera

Herramienta de control de concurrencia que permite poner en espera a n hilos hasta que todos hayan llegado al mismo punto, sin necesidad de una espera activa.
=== Variable de condicion

Es una herramienta de control de concurrencia que permite a los hilos esperar hasta que se cumpla una condicion especifica, permitiendo que otros hilos puedan modificar el estado de la condicion y notificar a los hilos en espera.

=== Candado de lectura y escritura
=== Descomposicion

Se refiere a la separacion de un trabajo en multiples tareas, facilitando el uso de concurrencia.

=== Mapeo

Se refiere a la asignacion de tareas a hilos, permitiendo que cada hilo realice una tarea especifica.

=== Incremento de velocidad

Se refiere a la mejoria en la cantidad de tiempo requerido para la finalizacion de un programa

=== Eficiencia

Es la relacion entre el tiempo de ejecucion de un programa tomando en cuenta la cantidad
de hilos utilizados y el tiempo de ejecucion del programa tomando en cuenta un solo hilo.

=== Comunicacion punto a punto entre procesos
=== Comunicacion colectiva entre procesos
=== Reduccion

Se refiere a la operacion de combinar los resultados de varios procesos en un solo resultado, por ejemplo, sumar los resultados de varios hilos en un solo resultado.