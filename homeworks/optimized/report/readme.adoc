= Reporte de optimizaciones
:toc-title: Tabla de contenidos
:experimental:
:nofooter:
:source-highlighter: pygments
:sectnums:
:stem: latexmath
:toc:
:xrefstyle: short



[[serial_optimizations]]
== Optimizaciones seriales
[%autowidth.stretch,options="header"]
|===
|Iter. |Etiqueta |Duración (s) |_Speedup_ |Descripción corta
|0 |Serial0 |70.909 |1.00 |Versión serial inicial (Tarea01)
|1 |Serial1 |45.551 |1.55 |Uso de array en lugar de matrices
|===


[[serial_iter00]]
=== Versión serial original (Tarea01)
La version serial00 contaba con dos matrices double [][] para manejar las
temperaturas actuales y las del siguiente estado.


[[serial_iter01]]
=== Iteración 1

Para la primera iteracion del serial, se reemplazo las dos matrices *double
temperatures[rows][columns]* por un solo array que almacena tanto las
temperaturas actuales como las siguientes. Al cambiar dichas dos matrices
por un solo array que contiene 2*(filas * columnas) celdas, se reduce
drasticamente la sobrecarga de memoria, el acceso a las posiciones y se
aprovechan mejor las capacidades de la memoria cache.

==== Antes :
[source, bash]
----
double ** temperatures
double ** next_temperatures

---------------------------

double** current = malloc(rows * sizeof(double*));
double** next = malloc(rows * sizeof(double*));

for (size_t i = 0; i < rows; i++) {
    temperatures[i] = malloc(columns * sizeof(double));
    next_temperatures[i] = malloc(columns * sizeof(double));
}
----

==== Despues:
[source, bash]
----
double * temperatures
---------------------
double* temperatures = malloc(2 * rows * columns * sizeof(double));
----

[[concurrent_optimizations]]
== Optimizaciones concurrentes

[%autowidth.stretch,options="header"]
|===
|Iter. |Etiqueta |Duración (s) |_Speedup_ |Eficiencia |Descripción corta
|- |SerialI |45.551 |1.00 |Versión serial final
|1 |Conc0 |740.903 |0.06 |1.54% |Versión concurrente inicial (Tarea02)
|2 |Conc01 |377.649 |0.12 |3.01% |
|3 | | | | |Versión concurrente final
|===


[[conc_iter00]]
=== Versión concurrente inicial (Tarea02)

La version original de Tarea02 tenia un problema muy serio con respecto a la optimizacion, pues creaba y destruia los registros privados y los hilos en cada cambio de estado de la lamina, generando un overhead muy alto

[[conc_iter01]]
=== Iteración 1

La primera optimizacion de la Tarea02 busco disminuir el overhead de la creacion y destruccion de hilos. Dicho proceso se realizaba dentro del while que cambiaba de estado k a estado k+1. Ahora se crean y destruyen los hilos una unica vez, utilizando barreras para el while que itera los estados, reduciendo significativamente el overhead de la creacion y destruccion de hilos, aumentando el rendimiento.

==== Antes:
[source, bash]
----
funcion update_lamina() {
    ...
    ...
    ...
    while (unstable blocks > 0) {
        ...
        ...
        ...
        for (size_t i = 0; i < thread_count; i++) {
            pthread_create(&threads[i], NULL, update_lamina_block,
            &private_data[i]) != 0);
        }
        ...
        ...
        ...
        for (size_t i = 0; i < thread_count; i++) {
            pthread_join(threads[i]);
        }
        ...
        ...
        ...
    }
}
----

==== Despues:
[source, bash]
----
funcion starThreads() {
    ...
    ...
    ...
    for (size_t i = 0; i < thread_count; i++) {
            pthread_create(&threads[i], NULL, update_lamina,
            &private_data[i]) != 0);
    }
    ...
    ...
    ...
    for (size_t i = 0; i < thread_count; i++) {
            pthread_join(threads[i]);
    }
}
funcion update_lamina() {
    while(true) {
        ...
        ...
        ...
        update_lamina_block()
        ...
        ...
        ...
        pthread_barrier_wait(&private_data->public_data->barrier);
    }
}
----
=== Iteración 2

[[optimization_comparison]]
=== Comparación de optimizaciones

(pendiente)


[[concurrency_comparison]]
=== Comparación del grado de concurrencia

(pendiente)

