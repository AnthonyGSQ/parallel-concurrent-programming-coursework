incluir lamina.h
// implementacion de las funciones
función lamina_constructor(argc, argv):
    return_value = 0

    // Verificar si los parámetros son suficientes
    si argc < 2:
        mostrar_error("Invalid entrance: you need to specify a .txt and the amount of threads you want to use")
        retornar EXIT_FAILURE

    // Intentar abrir el archivo .txt
    archivo = abrir_archivo(argv[1], "r")
    si archivo es NULL:
        mostrar_error("Error: could not open file")
        retornar EXIT_FAILURE

    // Leer línea por línea del archivo
    mientras haya líneas en archivo:
        lamina = reservar_memoria_para_Lamina()

        // Verificar si la memoria se ha asignado correctamente
        si lamina es NULL:
            mostrar_error("Error: could not allocate memory for Lamina")
            retornar EXIT_FAILURE

        // Establecer la ruta base
        establecer_ruta_base(lamina, argv[1])

        // Verificar que la ruta sea válida
        si ruta_invalida(lamina->base_route):
            mostrar_error("Error: invalid route")
            liberar_memoria(lamina)
            retornar EXIT_FAILURE

        // Leer y procesar la línea del archivo
        si línea_vacia(line):
            mostrar_error("Error: could not read a line from the .txt file")
            retornar EXIT_FAILURE

        // Leer los parámetros de la línea
        return_value = leer_parametros(lamina, lamina->binary_file_name, line)
        si return_value es EXIT_FAILURE:
            retornar EXIT_FAILURE

        // Intentar abrir el archivo binario de la lamina
        lamina->file = abrir_archivo(lamina->binary_file_name, "rb")
        mostrar("Creating lamina...")

        // Crear la lamina
        return_value = crear_lamina(lamina)
        si return_value es EXIT_FAILURE:
            retornar EXIT_FAILURE

        // Liberar la memoria de la lamina
        liberar_memoria(lamina)

    // Retornar éxito
    retornar EXIT_SUCCESS
FIN FUNCION

función reading_parameters(lamina, bin_file, line):
    // Inicializar buffer temporal
    temp = ""

    // Verificar que la línea contenga los 5 parámetros esperados
    si sscanf(line, "%s %" PRIu64 "%lf %lf %lf", temp, lamina->time, lamina->conductivity, lamina->height, lamina->epsilon) != 5:
        mostrar_error("Error: The file of configuration does not have the expected parameters")
        retornar EXIT_FAILURE
    FIN SI
    // Construir la ruta al archivo binario
    concatenar(lamina->binary_file_name, lamina->base_route, temp)
    imprimir("Binary file: %s", bin_file)
    imprimir("Time: %" PRIu64, lamina->time)

    // Verificar que los valores sean válidos
    si lamina->time == 0:
        mostrar_error("Invalid time")
        retornar EXIT_FAILURE
    FIN SI
    imprimir("Conductivity: %.f", lamina->conductivity)
    si lamina->conductivity <= 0:
        mostrar_error("Invalid conductivity")
        retornar EXIT_FAILURE
    FIN SI
    imprimir("Height: %.f", lamina->height)
    si lamina->height <= 0:
        mostrar_error("Invalid height")
        retornar EXIT_FAILURE
    FIN SI
    imprimir("Epsilon: %.15f", lamina->epsilon)
    si lamina->epsilon <= 0:
        mostrar_error("Invalid epsilon")
        retornar EXIT_FAILURE
    FIN SI
    retornar EXIT_SUCCESS
FIN FUNCION

función create_lamina(lamina):
    // Inicializar filas y columnas a 0 para evitar valores basura
    lamina->rows = 0
    lamina->columns = 0

    leer del binario la cantidad de filas
    leer del binario la cantidad de columnas
    crear las filas
    crear las columnas

retornar EXIT_SUCCESS

funcion fill_lamina(lamina) {
    Para i hasta lamina->rows hacer
        Para j hasta lamina->columns hacer
            leer el binario para guardar el numero [i][j] en su posicion
        fin Para
    Fin para
}
// esta funcion estara encargada de averiguar cuanto trabajo debe realizar cada
// thread, primeramente toma como parametro el valor mas alto entre
// filas y columnas, una vez hecho esto, cae en los siguientes casos:
// 1- Menos threads que el parametro: Divide la matriz thread_num/parametro
// 2- Cantidad de threads igual al parametro: Una linea por hilo
// (fila o columna) 
// 3- Mas threads que parametro: Aqui suceden 2 cosas:
// a) thread_num < filas * columnas: Seguimos la logica del caso 1 y dividimos
// el otro valor (si parametro es filas, este otro valor sera columnas y
// viceversa) hasta tener bloques suficientes para cada hilo
// TODO (AnthonyGSQ): falta decidir cual sera el tope para esto
// thread_num >= filas * columnas:  Asignamos un tope para evitar que cada hilo
// trabaje una celda pues esto no es eficiente, una vez asignado el tope
// le damos bloques de la matriz a cada hilo, el tope sera las dimensiones de
// este bloque
funcion plan_thread_distribution(lamina, fileobj) {
    Si lamina->rows >= lamina->columns hacer
        parameter := lamina->rows
    Sino hacer
        parameter := lamina->columns
    FIn si
    // Caso 1 y caso 2 (esta operacion cubre ambos, al menos en pseudo)
    Si thread_num < parameter hacer o thread_num == parameter
    matrix_block_size := lamina->temperatures_size / (thread_num/parameter)
    // Caso 3
    Sino
    // caso 3a
    // TODO(AnthonyGSQ): falta agregar el calculo del tope optimo, posiblemente
    // sea mejor hacerlo en tarea4
        Si thread_num < (lamina->rows * lamina->columns) hacer
            matrix_block_size := lamina->temperatures_size
                / (thread_num/parameter)
        // caso 3b
        Sino hacer
            thread_num := thread_num - tope_optimo;
            tomar caso 3a
        Fin si
}

función update_lamina(lamina):
    inicializar diff a 0
    inicializar unstable_cells a 1
    inicializar temp como NULL

    mientras unstable_cells > 0:
        // Resetea unstable_cells después de cada ciclo completo
        unstable_cells = 0

        // Resetea la matriz next_temperatures
        para cada fila i de 0 a lamina->rows:
            para cada columna j de 0 a lamina->columns:
                si la celda está en el borde:
                    continuar
                lamina->next_temperatures[i][j] = 0

        // Actualiza cada celda de la matriz
        para cada fila i de 0 a lamina->rows:
            para cada columna j de 0 a lamina->columns:
                si la celda está en el borde:
                    continuar
                actualizar_celda(lamina, i, j)
                diff = diferencia entre lamina->next_temperatures[i][j] y lamina->temperatures[i][j]
                si diff > lamina->epsilon:
                    unstable_cells++

        // Intercambia las matrices
        lamina->temperatures pasa a ser lamina->next_temperatures
        lamina->next_temperatures pasa a ser lamina->temperatures

        lamina->k += lamina->time
    FIN MIENTRAS

    imprimir "Lamina estabilizada"

    return_value = finish_simulation(lamina)
    si return_value == EXIT_FAILURE:
        retornar EXIT_FAILURE

retornar EXIT_SUCCESS

funcion void update_cell(OBJETO lamina, ENTERO row, ENTERO column) {
    // aseguramos que no se procesara una celda invalida
    Si la celda recibida no se sale de los bordes hacer 
        // formula para actualizar la temperatura de la celda
        lamina->next_temperatures[row][column] =
        lamina->temperatures[row][column] +
        ((lamina->k * lamina->conductivity) /
        (lamina->height * lamina->height)) *
        (up + down + right + left - (4 * lamina->temperatures[row][column]));
    FIN SI
}

funcion int finish_simulation(OBJETO lamina) {
    llamar a report_file
    SI report_file fallo hacer {
        retornar EXIT_FAILURE;
    }
    retornar EXIT_SUCCESS;
}

funcion void error_manager(Lamina *lamina, const char* error_message) {
    imprimir(error_message)
    Si lamina existe {
        delete_lamina(lamina);
    }
}

funcion void delete_lamina(OBJETO lamina) {
    SI existe lamina {
        SI existe lamina->temperaturas {
            liberar lamina->temperaturas
        }
        SI existe lamina->next_temperaturas {
            liberar lamina->next_temperaturas
        }
        SI existe lamina->file {
            liberar lamina->file
        }
        SI existe lamina->report_file {
            liberar lamina->report_file
        }
    }
}
